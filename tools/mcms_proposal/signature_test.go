package mcms_proposal

import (
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/smartcontractkit/ccip-owner-contracts/tools/gethwrappers"
	"github.com/stretchr/testify/assert"
)

func TestToGethSignature(t *testing.T) {
	sig := Signature{
		R: common.HexToHash("0x1234567890abcdef"),
		S: common.HexToHash("0xfedcba0987654321"),
		V: 27,
	}

	expected := gethwrappers.ManyChainMultiSigSignature{
		R: [32]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef},
		S: [32]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21},
		V: 27,
	}

	result := sig.ToGethSignature()
	assert.Equal(t, expected, result)
}

func TestNewSignatureFromBytes(t *testing.T) {
	sigBytes := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21,
		0x1b,
	}

	expected := Signature{
		R: common.HexToHash("0x1234567890abcdef"),
		S: common.HexToHash("0xfedcba0987654321"),
		V: 27,
	}

	result, err := NewSignatureFromBytes(sigBytes)
	assert.NoError(t, err)
	assert.Equal(t, expected, result)
}

func TestNewSignatureFromBytes_InvalidLength(t *testing.T) {
	sigBytes := []byte{
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
		0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21,
		0x1b,
	}

	_, err := NewSignatureFromBytes(sigBytes)
	assert.Error(t, err)
	assert.Equal(t, "invalid signature length: 17", err.Error())
}

func TestToBytes(t *testing.T) {
	sig := Signature{
		R: common.HexToHash("0x1234567890abcdef"),
		S: common.HexToHash("0xfedcba0987654321"),
		V: 27,
	}

	expected := []byte{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xfe, 0xdc, 0xba, 0x09, 0x87, 0x65, 0x43, 0x21,
		0x1b,
	}

	result := sig.ToBytes()
	assert.Equal(t, expected, result)
}

func TestRecover(t *testing.T) {
	pk, err := crypto.GenerateKey()
	assert.NoError(t, err)

	hash := common.HexToHash("0xabcdef1234567890")
	sig, err := crypto.Sign(hash.Bytes(), pk)
	assert.NoError(t, err)

	sigObj, err := NewSignatureFromBytes(sig)
	assert.NoError(t, err)

	expected := crypto.PubkeyToAddress(pk.PublicKey)

	result, err := sigObj.Recover(hash)
	assert.NoError(t, err)
	assert.Equal(t, expected, result)
}
